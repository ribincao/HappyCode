# DesignPatternByPython

## 设计问题

1. 僵化性：很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的改动
2. 脆弱性：对系统的改动会导致系统中和改动的地方在概念无关的许多地方出现问题
3. 牢固性：使之成为一些可在其他系统中重用的组件
4. 粘滞性：做正确的事情比做错误的事情要困难
5. 不必要的复杂性：设计中包含不具有任何好处的基础结构
6. 不必要的重复：设计中包含有重复结构，而该重复结构本可以使用单一的抽象进行统一
7. 晦涩性：很难阅读、理解，没有很好的表现出意图

## 设计原则

1. 单一职责原则`SRP`：就一个类而言，应该仅有一个引起它变化的原因

   - 职责指的是“变化的原因”

2. 开放封闭原则`OCP`：软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改的。

   - **封闭是建立在抽象和多态的基础之上的**

   - 对扩展开发，对接口关闭
   - 无论模块多么封闭，都会存在一些无法对之封闭的变化
   - 在我们认为可能发生变化的地方hook

3. `Liskov`替换原则`LSP`：子类型必须能够替换他们的基类型
   - 派生类的is-a关系是基于行为判断的

4. 依赖倒置原则`DIP`：上层模块 -> 抽象 -> 下层模块

   - 上层模块不应该依赖底层模块，它们都应该依赖于抽象
   - 抽象不应该依赖于细节，细节应该依赖于抽象
   - 原则
     - 任何变量都不应该持有一个指向具体类的指针或者引用
     - 任何类都不应该从具体类派生
     - 任何方法都不应该覆写它的任何基类中的已经实现了的方法

5. 接口隔离原则`ISP`：不应该强迫客户依赖于它们不用的方法

   - 使用多个专门的接口比使用单个接口要好很多

6. 迪米特法则(最少知识原则)：一个类对于其他类知道的越少越好

## 设计模式

### 结构型

- 代理模式：为其他对象提供一种代理以控制对这个对象的访问，在直接访问对象时带来的问题
- 外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口

### 行为型

- 中介者模式：降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信
- 观察者模式：对象间存在一对多关系时，当一个对象被修改时会自动通知依赖它的对象
- 命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化

### 创建型

- 单例模式：类负责创建自己的对象，同时确保只有单个对象被创建